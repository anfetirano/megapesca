üß≠ Manual de conexi√≥n: Shopify + Clerk + Convex + Next.js + Wompi (Megapesca)
üìå Objetivo general

Conectar Shopify (cat√°logo y checkout con Wompi) con tu ecosistema actual basado en:

Next.js (Frontend + Dashboard)

Clerk (autenticaci√≥n y roles)

Convex (base de datos y backend)

Wompi (pasarela de pago oficial de Shopify en Colombia)

De esta forma, Megapesca mantiene:

La tienda y pagos dentro de Shopify.

La experiencia de usuario (dashboards, comunidad, fidelizaci√≥n) dentro de Next.js.

Y la sincronizaci√≥n de datos (usuarios, pedidos, m√©tricas) centralizada en Convex.

‚öôÔ∏è Estructura general
megapesca/
‚îú‚îÄ‚îÄ convex/
‚îÇ   ‚îú‚îÄ‚îÄ functions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.ts        ‚Üí Manejo de roles y auth Clerk
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.ts       ‚Üí Sincronizaci√≥n de pedidos Shopify
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.ts     ‚Üí Cache y metadatos del cat√°logo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhooks.ts     ‚Üí Recepci√≥n de eventos Shopify/Wompi
‚îÇ   ‚îî‚îÄ‚îÄ schema.ts
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ (auth)/         ‚Üí Login/Register Clerk
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/      ‚Üí Panel con m√©tricas Shopify
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client/     ‚Üí Panel con historial y compras
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ (marketing)/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ home/       ‚Üí P√°gina principal
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ shop/       ‚Üí Cat√°logo (fetch desde Shopify API)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ shopifyClient.ts  ‚Üí Conector a Storefront/Admin API
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ convexClient.ts   ‚Üí Cliente de Convex
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ .env.local
‚îî‚îÄ‚îÄ README_SHOPIFY.md

üß© Rol de cada servicio
Servicio	Rol	Descripci√≥n
Shopify	E-commerce principal	Maneja cat√°logo, inventario y checkout con Wompi.
Wompi (plugin oficial)	Pasarela de pago	Procesa pagos directamente desde el checkout de Shopify, sin redirecci√≥n.
Clerk	Autenticaci√≥n	Crea y mantiene sesiones seguras para clientes y administradores.
Convex	Base de datos + backend	Guarda usuarios, pedidos, estad√≠sticas, y roles.
Next.js	Interfaz	Aloja el dashboard (admin/client) y el frontend marketing.
üß† Flujo completo del sistema
1Ô∏è‚É£ Registro y autenticaci√≥n

El usuario crea cuenta o inicia sesi√≥n con Clerk.

Convex ensureMe() sincroniza o crea el documento user con sus datos.

Se asigna el rol:

"admin" si su email o ID est√° en ADMIN_EMAILS o ADMIN_SUBJECTS.

"client" por defecto.

2Ô∏è‚É£ Cat√°logo y tienda

Shopify mantiene todo el inventario y precios.

Desde /shop, Next.js obtiene los productos usando la Storefront API:

import { shopifyFetch } from "@/lib/shopifyClient";

export default async function ShopPage() {
  const data = await shopifyFetch(`
    query Products {
      products(first: 12) {
        edges {
          node {
            id title handle
            images(first: 1) { edges { node { src } } }
            priceRange { minVariantPrice { amount currencyCode } }
          }
        }
      }
    }
  `);
  const products = data.products.edges.map(e => e.node);
  ...
}


Convex puede tener un products table opcional para cachear los productos y a√±adir etiquetas, stock local, o categor√≠as personalizadas.

3Ô∏è‚É£ Checkout y pagos (Shopify + Wompi)
Integraci√≥n oficial Wompi para Shopify

Instala el plugin oficial de Wompi desde el panel de Shopify:

Configuraci√≥n ‚Üí Pagos ‚Üí Conectar ‚Üí Wompi.

Ingresa tus credenciales de producci√≥n y prueba desde tu cuenta Wompi:

Panel Wompi ‚Üí Desarrollo ‚Üí Desarrolladores ‚Üí Llaves p√∫blicas/privadas.

Activa los m√©todos de pago deseados:

Tarjetas cr√©dito/d√©bito.

PSE, Nequi, Daviplata, QR Bancolombia, efectivo, etc.

Modos disponibles

Checkout redirigido (Wompi est√°ndar)
El usuario es llevado a la pasarela de Wompi y regresa al confirmar el pago.

Tarjetas on-site (integrado)
El pago se realiza directamente dentro del checkout de Shopify sin salir de la tienda.
‚ö†Ô∏è Requiere habilitar ‚ÄúWompi tarjetas‚Äù desde la app oficial.

Webhook de estado

Wompi notificar√° autom√°ticamente los pagos a Shopify.

Shopify actualizar√° el pedido (pagado, pendiente, cancelado, etc.).

Puedes crear un webhook adicional en Convex o Next.js para sincronizar estados si lo deseas:

// /api/webhooks/shopify.ts
export async function POST(req: Request) {
  const event = await req.json();
  // Ejemplo: order paid ‚Üí guardar en Convex
  if (event.topic === "orders/paid") {
    await convex.mutation("orders.syncFromShopify", { orderId: event.data.id });
  }
  return new Response("ok");
}

4Ô∏è‚É£ Dashboard Cliente (Convex + Clerk)

Accesible solo para usuarios autenticados con role: client.

Muestra datos del usuario y sus pedidos, sincronizados desde Shopify ‚Üí Convex.

Ejemplo de consulta:

const orders = useQuery(api.functions.orders.listMine, {});


Incluye:

Historial de compras.

Estados de pedido.

Productos favoritos.

Datos b√°sicos del perfil.

5Ô∏è‚É£ Dashboard Admin (Shopify + Convex)

Solo para role: admin.

Muestra m√©tricas como:

Ventas totales y del d√≠a.

Pedidos pendientes.

Nuevos clientes.

Fuente de datos combinada:

Shopify Admin API para ventas reales.

Convex orders para datos internos y m√©tricas personalizadas.

Ejemplo:

const { admin } = await authenticate.admin(request);
const response = await admin.graphql(`
  query {
    orders(first: 5, sortKey: CREATED_AT, reverse: true) {
      edges { node { name totalPriceSet { shopMoney { amount } } } }
    }
  }
`);

üîê Variables de entorno
# Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=...
CLERK_SECRET_KEY=...

# Convex
CONVEX_DEPLOYMENT=...

# Shopify
NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN=megapesca.myshopify.com
NEXT_PUBLIC_SHOPIFY_STOREFRONT_API_TOKEN=...
SHOPIFY_ADMIN_API_KEY=...
SHOPIFY_ADMIN_API_SECRET=...
SHOPIFY_API_VERSION=2025-07
SHOPIFY_APP_URL=https://megapesca.co

# Wompi
WOMPI_PUBLIC_KEY=...
WOMPI_PRIVATE_KEY=...
WOMPI_EVENTS_SECRET=...

üìñ Instrucciones oficiales de Wompi (Shopify)

üîó Seguir gu√≠a completa:
Documentaci√≥n oficial de integraci√≥n Wompi + Shopify

Pasos esenciales resumidos:

En Shopify ‚Üí Configuraci√≥n ‚Üí Pagos ‚Üí ‚ÄúWompi‚Äù.

Clic en Conectar e instala la app.

Inicia sesi√≥n con tus credenciales Wompi y copia las llaves.

Conecta en modo prueba y verifica funcionamiento.

Luego conecta modo producci√≥n y activa los m√©todos de pago.

Configura:

M√©todo de contacto: ‚ÄúCorreo electr√≥nico‚Äù.

N√∫mero de tel√©fono de env√≠o: ‚ÄúRequerido‚Äù.

(Opcional) Activa Wompi tarjetas on-site para pagos dentro del checkout.

Verifica que los pedidos se reflejen correctamente en Shopify.

üß© Mapa de flujo final
Cliente ‚Üí Clerk ‚Üí Convex(users)
   ‚Üì
Tienda Next.js (/shop) ‚Üí Shopify Storefront API
   ‚Üì
Checkout Shopify ‚Üí Wompi (plugin oficial)
   ‚Üì
Webhook Wompi ‚Üí Shopify actualiza estado
   ‚Üì
Convex sincroniza datos ‚Üí Dashboard Cliente/Admin

‚úÖ Recomendaciones finales

Usa el plugin oficial de Wompi.
No reinventes el checkout: Shopify ya se encarga del pago seguro.

Sincroniza datos clave a Convex:

shopifyOrderId

userId (Clerk)

status (paid, pending, cancelled)

totalPrice

Evita conectar Convex directo a Wompi.
Deja que Shopify reciba y valide los pagos.

Convex act√∫a como ‚Äúmirror‚Äù o espejo de datos.

Cada vez que Shopify reciba un pedido o lo actualice ‚Üí Convex lo refleja.

Dashboard futuro:

Cliente: pedidos, estado, soporte.

Admin: m√©tricas de Shopify + datos de usuarios Convex.

Aqu√≠ tienes el blueprint s√≥lido para conectar Shopify con tu stack (Next.js + Clerk + Convex) sin romper nada. Puedes copiar/pegar por archivos. Est√° pensado para ir en una rama nueva: feat/shopify-catalogue.

1) Convex ‚Äì schema.ts (a√±ade estas tablas/√≠ndices)
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // --- YA EXISTE: users ---
  users: defineTable({
    clerkId: v.string(),
    createdAt: v.float64(),
    email: v.optional(v.string()),
    image: v.optional(v.string()),
    name: v.optional(v.string()),
    role: v.union(v.literal("client"), v.literal("admin")),
  })
    .index("by_clerkId", ["clerkId"])
    .index("by_email", ["email"])
    .searchIndex("search_by_email", {
      searchField: "email",
    }),

  // --- NUEVO: orders (espejo de Shopify) ---
  orders: defineTable({
    userId: v.id("users"),                // due√±a del pedido (Clerk‚ÜíConvex)
    shopifyOrderId: v.string(),           // id de Shopify (gid o num√©rico)
    name: v.string(),                     // # pedido: ej. #1001
    status: v.string(),                   // paid, pending, cancelled...
    currencyCode: v.optional(v.string()),
    totalPrice: v.optional(v.float64()),
    subtotalPrice: v.optional(v.float64()),
    createdAt: v.float64(),               // timestamp ms
    updatedAt: v.float64(),               // timestamp ms
    raw: v.optional(v.any()),             // snapshot raw (para auditor√≠a)
  })
    .index("by_user", ["userId"])
    .index("by_shopifyId", ["shopifyOrderId"]),

  // --- NUEVO: orderItems (l√≠neas del pedido) ---
  orderItems: defineTable({
    orderId: v.id("orders"),
    shopifyProductId: v.optional(v.string()),
    title: v.string(),
    quantity: v.float64(),
    price: v.float64(),
  }).index("by_order", ["orderId"]),

  // --- OPCIONAL: productCache (cat√°logo cacheado) ---
  productCache: defineTable({
    shopifyProductId: v.string(),
    title: v.string(),
    handle: v.string(),
    image: v.optional(v.string()),
    price: v.optional(v.float64()),
    currencyCode: v.optional(v.string()),
    updatedAt: v.float64(),
    raw: v.optional(v.any()),
  })
    .index("by_handle", ["handle"])
    .index("by_shopifyProductId", ["shopifyProductId"]),
});

2) Convex ‚Äì functions/orders.ts
// convex/functions/orders.ts
import { mutation, query } from "../_generated/server";
import { v } from "convex/values";

/**
 * Utilidad: resuelve el user (Convex) a partir del clerkId actual
 */
async function getMeByClerkId(ctx: any) {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) throw new Error("UNAUTHORIZED");
  const me =
    await ctx.db.query("users")
      .withIndex("by_clerkId", (q: any) => q.eq("clerkId", identity.subject))
      .unique();
  if (!me) throw new Error("USER_NOT_FOUND");
  return me;
}

/**
 * Query: lista mis pedidos (cliente autenticado)
 */
export const listMine = query({
  args: {},
  handler: async (ctx) => {
    const me = await getMeByClerkId(ctx);
    const orders = await ctx.db
      .query("orders")
      .withIndex("by_user", (q: any) => q.eq("userId", me._id))
      .collect();

    // Opcional: ordenar por fecha desc
    orders.sort((a: any, b: any) => b.createdAt - a.createdAt);
    return orders;
  },
});

/**
 * Query: lista recientes (admin)
 */
export const listRecent = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, { limit }) => {
    const me = await getMeByClerkId(ctx);
    if (me.role !== "admin") throw new Error("FORBIDDEN");

    // Simple: trae todos y corta (puedes usar paginaci√≥n m√°s adelante)
    const orders = await ctx.db.query("orders").collect();
    orders.sort((a: any, b: any) => b.createdAt - a.createdAt);
    return orders.slice(0, limit ?? 50);
  },
});

/**
 * Mutation: sincroniza un pedido desde payload de Shopify (webhook o admin API)
 * Espera un objeto shape m√≠nimo con campos est√°ndar
 */
export const syncFromShopify = mutation({
  args: {
    shopifyOrderId: v.string(),
    name: v.string(),
    email: v.optional(v.string()),
    currencyCode: v.optional(v.string()),
    totalPrice: v.optional(v.number()),
    subtotalPrice: v.optional(v.number()),
    status: v.string(),
    createdAt: v.number(), // ms
    updatedAt: v.number(), // ms
    items: v.optional(
      v.array(
        v.object({
          title: v.string(),
          quantity: v.number(),
          price: v.number(),
          shopifyProductId: v.optional(v.string()),
        })
      )
    ),
    raw: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    // 1) Buscar user por email (o mantener mapeo externo tienda‚Üíusuario)
    let userId = null;

    if (args.email) {
      const lower = args.email.toLowerCase();
      const byEmail = await ctx.db
        .query("users")
        .withIndex("by_email", (q: any) => q.eq("email", lower))
        .unique();
      if (byEmail) userId = byEmail._id;
    }

    // Si no hay userId, puedes crear un "guest holder" o dejarlo null y luego repararlo
    if (!userId) {
      // Opcional: reg√≠stralo como guest en el futuro
      // Por ahora, lanzamos para mantener data consistente:
      // throw new Error("ORDER_WITHOUT_USER");
    }

    // 2) Upsert del pedido
    const existing = await ctx.db
      .query("orders")
      .withIndex("by_shopifyId", (q: any) => q.eq("shopifyOrderId", args.shopifyOrderId))
      .unique();

    let orderId;
    if (!existing) {
      orderId = await ctx.db.insert("orders", {
        userId: userId ?? (await getMeByClerkId(ctx))._id, // fallback si llega autenticado
        shopifyOrderId: args.shopifyOrderId,
        name: args.name,
        status: args.status,
        currencyCode: args.currencyCode,
        totalPrice: args.totalPrice ?? undefined,
        subtotalPrice: args.subtotalPrice ?? undefined,
        createdAt: args.createdAt,
        updatedAt: args.updatedAt,
        raw: args.raw ?? undefined,
      });
    } else {
      await ctx.db.patch(existing._id, {
        name: args.name,
        status: args.status,
        currencyCode: args.currencyCode ?? existing.currencyCode,
        totalPrice: args.totalPrice ?? existing.totalPrice,
        subtotalPrice: args.subtotalPrice ?? existing.subtotalPrice,
        updatedAt: args.updatedAt,
        raw: args.raw ?? existing.raw,
      });
      orderId = existing._id;
    }

    // 3) Reemplazar items (simple)
    if (args.items && args.items.length) {
      // borra items existentes
      const oldItems = await ctx.db
        .query("orderItems")
        .withIndex("by_order", (q: any) => q.eq("orderId", orderId))
        .collect();
      await Promise.all(oldItems.map((it: any) => ctx.db.delete(it._id)));

      // inserta nuevos
      for (const it of args.items) {
        await ctx.db.insert("orderItems", {
          orderId,
          shopifyProductId: it.shopifyProductId ?? undefined,
          title: it.title,
          quantity: it.quantity,
          price: it.price,
        });
      }
    }

    return await ctx.db.get(orderId);
  },
});

3) Convex ‚Äì functions/products.ts (opcional cache de cat√°logo)
// convex/functions/products.ts
import { mutation, query } from "../_generated/server";
import { v } from "convex/values";

export const listCached = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, { limit }) => {
    const all = await ctx.db.query("productCache").collect();
    all.sort((a: any, b: any) => b.updatedAt - a.updatedAt);
    return all.slice(0, limit ?? 50);
  },
});

export const upsertCache = mutation({
  args: {
    shopifyProductId: v.string(),
    title: v.string(),
    handle: v.string(),
    image: v.optional(v.string()),
    price: v.optional(v.number()),
    currencyCode: v.optional(v.string()),
    raw: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("productCache")
      .withIndex("by_shopifyProductId", (q: any) => q.eq("shopifyProductId", args.shopifyProductId))
      .unique();

    if (!existing) {
      const id = await ctx.db.insert("productCache", {
        ...args,
        updatedAt: Date.now(),
      });
      return await ctx.db.get(id);
    } else {
      await ctx.db.patch(existing._id, {
        ...args,
        updatedAt: Date.now(),
      });
      return await ctx.db.get(existing._id);
    }
  },
});

4) Next.js ‚Äì src/lib/shopifyClient.ts
// src/lib/shopifyClient.ts
const STORE_DOMAIN = process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN!;
const SF_TOKEN = process.env.NEXT_PUBLIC_SHOPIFY_STOREFRONT_API_TOKEN!;
const ADMIN_KEY = process.env.SHOPIFY_ADMIN_API_KEY!;
const ADMIN_SECRET = process.env.SHOPIFY_ADMIN_API_SECRET!;
const API_VERSION = process.env.SHOPIFY_API_VERSION || "2025-07";

// Storefront GraphQL (cat√°logo p√∫blico)
export async function shopifyStorefrontFetch<T = any>(query: string, variables?: Record<string, any>) {
  const res = await fetch(`https://${STORE_DOMAIN}/api/${API_VERSION}/graphql.json`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Shopify-Storefront-Access-Token": SF_TOKEN,
    },
    body: JSON.stringify({ query, variables }),
    cache: "no-store",
  });
  if (!res.ok) throw new Error(`Storefront API error: ${res.status}`);
  const json = await res.json();
  if (json.errors) throw new Error(JSON.stringify(json.errors));
  return json.data as T;
}

// Admin GraphQL (privado ‚Äì pedidos, etc.)
export async function shopifyAdminFetch<T = any>(query: string, variables?: Record<string, any>) {
  const res = await fetch(`https://${STORE_DOMAIN}/admin/api/${API_VERSION}/graphql.json`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Shopify-Access-Token": ADMIN_SECRET || ADMIN_KEY, // seg√∫n configuraci√≥n
    },
    body: JSON.stringify({ query, variables }),
    cache: "no-store",
  });
  if (!res.ok) throw new Error(`Admin API error: ${res.status}`);
  const json = await res.json();
  if (json.errors) throw new Error(JSON.stringify(json.errors));
  return json.data as T;
}

5) Next.js ‚Äì /app/(marketing)/shop/page.tsx (cat√°logo real desde Storefront)
// src/app/(marketing)/shop/page.tsx
import { shopifyStorefrontFetch } from "@/lib/shopifyClient";

export default async function ShopPage() {
  const data = await shopifyStorefrontFetch<{
    products: {
      edges: {
        node: {
          id: string;
          title: string;
          handle: string;
          images: { edges: { node: { src?: string; url?: string } }[] };
          priceRange: { minVariantPrice: { amount: string; currencyCode: string } };
        };
      }[];
    };
  }>(`
    query Products {
      products(first: 12) {
        edges {
          node {
            id
            title
            handle
            images(first: 1) { edges { node { url } } }
            priceRange { minVariantPrice { amount currencyCode } }
          }
        }
      }
    }
  `);

  const products = data.products.edges.map((e) => e.node);

  return (
    <main className="min-h-screen bg-black text-white p-6">
      <h1 className="text-2xl font-bold mb-6">Tienda</h1>
      <div className="grid grid-cols-2 md:grid-cols-3 gap-5">
        {products.map((p) => {
          const img = p.images.edges[0]?.node?.url;
          const price = p.priceRange.minVariantPrice;
          return (
            <a
              key={p.id}
              href={`https://${process.env.NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN}/products/${p.handle}`}
              className="rounded-xl border border-white/10 bg-white/5 overflow-hidden"
            >
              <div className="aspect-square bg-white/5 grid place-items-center text-zinc-500">
                {img ? <img src={img} alt={p.title} className="h-full w-full object-cover" /> : "Sin imagen"}
              </div>
              <div className="p-3">
                <h3 className="font-semibold">{p.title}</h3>
                <p className="text-sm text-zinc-400">
                  {price.amount} {price.currencyCode}
                </p>
              </div>
            </a>
          );
        })}
      </div>
    </main>
  );
}


Nota: de momento linkeo cada producto al PDP de tu tienda Shopify (r√°pido y robusto). M√°s adelante puedes hacer PDPs propios en Next y crear el checkout v√≠a cart API si lo deseas.

6) Next.js ‚Äì Webhook de Shopify (opcional espejo ‚Üí Convex)

Shopify requiere verificar HMAC. Este handler es el esqueleto:

// src/app/api/webhooks/shopify/route.ts
import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import { shopifyAdminFetch } from "@/lib/shopifyClient";
import { createClient } from "@convex-dev/convex-labs"; // o usa fetch a /api/convex si prefieres
// ‚Üë reemplaza por tu forma habitual de invocar Convex desde server (RSC).

const SHOPIFY_WEBHOOK_SECRET = process.env.SHOPIFY_WEBHOOK_SECRET!;

function verifyHmac(rawBody: string, hmacHeader?: string | null) {
  if (!hmacHeader) return false;
  const digest = crypto
    .createHmac("sha256", SHOPIFY_WEBHOOK_SECRET)
    .update(rawBody, "utf8")
    .digest("base64");
  return crypto.timingSafeEqual(Buffer.from(digest), Buffer.from(hmacHeader));
}

export async function POST(req: NextRequest) {
  const rawBody = await req.text();
  const hmacHeader = req.headers.get("x-shopify-hmac-sha256");
  const topic = req.headers.get("x-shopify-topic");

  if (!verifyHmac(rawBody, hmacHeader)) {
    return NextResponse.json({ ok: false, error: "INVALID_HMAC" }, { status: 401 });
  }

  const payload = JSON.parse(rawBody);

  // Ejemplo: orders/paid ‚Üí llama a Admin API para ampliar detalles si lo deseas
  if (topic?.startsWith("orders/")) {
    // Mapea a tu payload para Convex
    const order = payload; // ya trae casi todo en webhooks
    const items =
      order?.line_items?.map((li: any) => ({
        title: li.title,
        quantity: Number(li.quantity),
        price: Number(li.price),
        shopifyProductId: li.product_id ? String(li.product_id) : undefined,
      })) ?? [];

    // Convierte a milisegundos
    const createdAt = Number(new Date(order.created_at).getTime());
    const updatedAt = Number(new Date(order.updated_at).getTime());

    // Llama a Convex (usa tu cliente/endpoint de server)
    // Pseudoc√≥digo (aj√∫stalo a tu m√©todo real):
    // await convex.mutation("orders.syncFromShopify", {...})
    // Si usas fetch a una API interna que a su vez llama a Convex, hazlo ah√≠.

    // Respuesta
    return NextResponse.json({ ok: true });
  }

  return NextResponse.json({ ok: true });
}


Importante: en producci√≥n configura el webhook en Shopify a esta ruta (/api/webhooks/shopify) y define SHOPIFY_WEBHOOK_SECRET.

7) Variables de entorno (a√±ade/ajusta)
# Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=...
CLERK_SECRET_KEY=...

# Convex
CONVEX_DEPLOYMENT=...
NEXT_PUBLIC_CONVEX_URL=...

# Shopify
NEXT_PUBLIC_SHOPIFY_STORE_DOMAIN=megapesca.myshopify.com
NEXT_PUBLIC_SHOPIFY_STOREFRONT_API_TOKEN=...
SHOPIFY_ADMIN_API_KEY=...
SHOPIFY_ADMIN_API_SECRET=...
SHOPIFY_API_VERSION=2025-07
SHOPIFY_WEBHOOK_SECRET=...

# Wompi (SOLO para referencia; en Shopify se configuran en la app oficial)
WOMPI_PUBLIC_KEY=...
WOMPI_PRIVATE_KEY=...
WOMPI_EVENTS_SECRET=...

8) UI m√≠nima en dashboards

Cliente (/dashboard/client/page.tsx) ‚Äì ya tienes captures; a√±ade pedidos:

// snippet: a√±ade debajo de "captures"
const orders = useQuery(api.functions.orders.listMine, {});
/* Renderiza:
orders?.map(o => (
  <li key={o._id}>#{o.name} ‚Äî {o.totalPrice ?? "‚Äî"} {o.currencyCode ?? ""} ‚Äî {o.status}</li>
))
*/


Admin (/dashboard/admin/page.tsx) ‚Äì m√©trica simple:

const recent = useQuery(api.functions.orders.listRecent, { limit: 10 });
/* Render: total √∫ltimos N, listado, etc. */

¬øQu√© queda listo con este blueprint?

‚úÖ Cat√°logo /shop desde Shopify Storefront.

‚úÖ Esquema Convex para orders e items (mirror).

‚úÖ Mutaci√≥n syncFromShopify para registrar/actualizar pedidos.

‚úÖ Hooks de cliente/admin para listar pedidos.

‚úÖ Webhook de Shopify (esqueleto con HMAC).

Con esto ya puedes:

Mostrar productos reales en /shop.

Recibir pedidos en Shopify con Wompi (plugin oficial).

Sincronizar pedidos a Convex (cuando actives el webhook).

Ver pedidos por usuario en el dashboard cliente y m√©tricas en admin.